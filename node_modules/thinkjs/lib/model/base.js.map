{"version":3,"sources":["../../src/model/base.js"],"names":[],"mappings":"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","file":"base.js","sourcesContent":["'use strict';\n\nimport util from 'util';\nimport Base from './_base.js';\n\n/**\n * model base class\n * @type {Class}\n */\nexport default class extends Base {\n  /**\n   * get table schema\n   * @param  {String} table [table name]\n   * @return {}       []\n   */\n  async getSchema(table){\n    table = table || this.getTableName();\n    let storeKey = `${this.config.type}_${table}_schema`;\n    let schema = {};\n    //force update table schema\n    if(this.config.schema_force_update){\n      schema = await this.db().getSchema(table);\n    }else{\n      schema = thinkCache(thinkCache.TABLE, storeKey);\n      if(!schema){\n        schema = await this.db().getSchema(table);\n        thinkCache(thinkCache.TABLE, storeKey, schema);\n      }\n    }\n    if(table !== this.getTableName()){\n      return schema;\n    }\n    //get primary key\n    for(let name in schema){\n      if(schema[name].primary){\n        this.pk = name;\n        break;\n      }\n    }\n    //merge user set schema config\n    this.schema = think.extend({}, schema, this.schema);\n    return this.schema;\n  }\n  /**\n   * get table fields\n   * @param  {String} table []\n   * @return {Promise}       []\n   */\n  getTableFields(table){\n    think.log('model.getTableFields is deprecated, use model.getSchema instead.', 'WARNING');\n    return this.getSchema(table);\n  }\n  /**\n   * get unique field\n   * @param  {Object} data []\n   * @return {Promise}      []\n   */\n  async getUniqueField(data){\n    let schema = await this.getSchema();\n    for(let name in schema){\n      if(schema[name].unique && (!data || data[name])){\n        return name;\n      }\n    }\n  }\n  /**\n   * get last sql\n   * @return {Promise} []\n   */\n  getLastSql(){\n    return this.db().getLastSql();\n  }\n  /**\n   * get primary key\n   * @return {Promise} []\n   */\n  getPk(){\n    if(this.pk !== 'id'){\n      return Promise.resolve(this.pk);\n    }\n    return this.getSchema().then(() => this.pk);\n  }\n  /**\n   * build sql\n   * @param  {[type]} options [description]\n   * @return {[type]}         [description]\n   */\n  async buildSql(options){\n    options = await this.parseOptions(options);\n    return '( ' + this.db().buildSelectSql(options).trim() + ' )';\n  }\n  /**\n   * parse options\n   * @param  {Object} options []\n   * @return promise         []\n   */\n  async parseOptions(oriOpts, extraOptions){\n    let options = think.extend({}, this._options);\n    if (think.isObject(oriOpts)) {\n      options = think.extend(options, oriOpts);\n    }\n    if(extraOptions){\n      options = think.extend(options, extraOptions);\n    }\n    //clear options\n    this._options = {};\n    //get table name\n    options.table = options.table || this.getTableName();\n\n    options.tablePrefix = this.getTablePrefix();\n    options.model = this.getModelName();\n\n    //get table schema can not use table alias\n    let schema = await this.getSchema(options.table);\n\n    //table alias\n    if (options.alias) {\n      options.table += ' AS ' + options.alias;\n    }\n\n    if(oriOpts !== undefined && !think.isObject(oriOpts)){\n      options = think.extend(options, this.parseWhereOptions(oriOpts));\n    }\n    //check where key\n    if(options.where && !think.isEmpty(schema)){\n      let keyReg = /^[\\w\\.\\|\\&]+$/;\n      for(let key in options.where){\n        if(!keyReg.test(key)){\n          let msg = new Error(think.locale('FIELD_KEY_NOT_VALID', key));\n          return think.reject(msg);\n        }\n      }\n    }\n    //field reverse\n    if(options.field && options.fieldReverse){\n      //reset fieldReverse value\n      options.fieldReverse = false;\n      let optionsField = options.field;\n      options.field = Object.keys(schema).filter(item => {\n        if(optionsField.indexOf(item) === -1){\n          return item;\n        }\n      });\n    }\n    return this.optionsFilter(options, schema);\n  }\n  /**\n   * parse where options\n   * @return {Object}\n   */\n  parseWhereOptions(options){\n    if (think.isNumber(options) || think.isString(options)) {\n      options += '';\n      let where = {\n        [this.pk]: options.indexOf(',') > -1 ? {IN: options} : options\n      };\n      return {where: where};\n    }\n    return options;\n  }\n  /**\n   * parse type\n   * @param  {Object} data []\n   * @param  {} key  []\n   * @return {}      []\n   */\n  parseType(key, value){\n    let fieldType = this.schema[key].type || '';\n    if (fieldType.indexOf('bigint') === -1 && fieldType.indexOf('int') > -1) {\n      return parseInt(value, 10) || 0;\n    }else if(fieldType.indexOf('double') > -1 || fieldType.indexOf('float') > -1){\n      return parseFloat(value) || 0.0;\n    }else if(fieldType.indexOf('bool') > -1){\n      return !!value;\n    }\n    return value;\n  }\n  /**\n   * parse data, after fields getted\n   * @param  {} data []\n   * @return {}      []\n   */\n  parseData(data){\n    //deep clone data\n    data = think.extend({}, data);\n    for(let key in data){\n      let val = data[key];\n      //remove data not in fields\n      if (!this.schema[key]) {\n        delete data[key];\n      }else if(think.isNumber(val) || think.isString(val) || think.isBoolean(val)){\n        data[key] = this.parseType(key, val);\n      }\n    }\n    return this.dataFilter(data);\n  }\n  /**\n   * add data\n   * @param {Object} data    []\n   * @param {Object} options []\n   * @param {} replace []\n   */\n  async add(data, options, replace){\n    if (options === true) {\n      replace = true;\n      options = {};\n    }\n    //copy data\n    data = think.extend({}, this._data, data);\n    //clear data\n    this._data = {};\n\n    options = await this.parseOptions(options);\n\n    let parsedData = this.parseData(data);\n    parsedData = await this.beforeAdd(parsedData, options);\n    if (think.isEmpty(parsedData)) {\n      let msg = new Error(think.locale('DATA_EMPTY'));\n      return think.reject(msg);\n    }\n\n    await this.db().add(parsedData, options, replace);\n    let insertId = parsedData[this.pk] = this.db().getLastInsertId();\n    let copyData = think.extend({}, data, parsedData, {[this.pk]: insertId});\n    await this.afterAdd(copyData, options);\n    return insertId;\n  }\n  /**\n   * add data when not exist\n   * @param  {Object} data       []\n   * @param  {Object} where      []\n   * @return {}            []\n   */\n  async thenAdd(data, where){\n    let findData = await this.where(where).find();\n    if(!think.isEmpty(findData)){\n      return {[this.pk]: findData[this.pk], type: 'exist'};\n    }\n    let insertId = await this.add(data);\n    return {[this.pk]: insertId, type: 'add'};\n  }\n  /**\n   * update data when exist, otherwise add data\n   * @return {id}\n   */\n  async thenUpdate(data, where){\n    let findData = await this.where(where).find();\n    if(think.isEmpty(findData)){\n      return this.add(data);\n    }\n    await this.where(where).update(data);\n    return findData[this.pk];\n  }\n  /**\n   * add multi data\n   * @param {Object} data    []\n   * @param {} options []\n   * @param {} replace []\n   */\n  async addMany(data, options, replace){\n    if (!think.isArray(data) || !think.isObject(data[0])) {\n      return think.reject(new Error(think.locale('DATA_MUST_BE_ARRAY')));\n    }\n    if (options === true) {\n      replace = true;\n      options = {};\n    }\n    options = await this.parseOptions(options);\n    let promises = data.map(item => {\n      item = this.parseData(item);\n      return this.beforeAdd(item, options);\n    });\n    data = await Promise.all(promises);\n    await this.db().addMany(data, options, replace);\n    let insertId = this.db().getLastInsertId();\n    let insertIds = [];\n    promises = data.map((item, i) => {\n      let id = insertId + i;\n      item[this.pk] = id;\n      insertIds.push(id);\n      return this.afterAdd(item, options);\n    });\n    data = await Promise.all(promises);\n    return insertIds;\n  }\n  /**\n   * delete data\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async delete(options){\n    options = await this.parseOptions(options);\n    options = await this.beforeDelete(options);\n    let rows = await this.db().delete(options);\n    await this.afterDelete(options);\n    return rows;\n  }\n  /**\n   * update data\n   * @param  {Object} data      []\n   * @param  {Object} options   []\n   * @param  {Boolean} ignoreWhere []\n   * @return {Promise}          []\n   */\n  async update(data, options){\n\n    data = think.extend({}, this._data, data);\n    //clear data\n    this._data = {};\n\n    options = await this.parseOptions(options);\n\n    let parsedData = this.parseData(data);\n\n    //check where condition\n    if(think.isEmpty(options.where)){\n      //get where condition from data\n      let pk = await this.getPk();\n      if(parsedData[pk]){\n        options.where = {[pk]: parsedData[pk]};\n        delete parsedData[pk];\n      }else{\n        return think.reject(new Error(think.locale('MISS_WHERE_CONDITION')));\n      }\n    }\n\n    parsedData = await this.beforeUpdate(parsedData, options);\n    //check data is empty\n    if (think.isEmpty(parsedData)) {\n      return think.reject(new Error(think.locale('DATA_EMPTY')));\n    }\n\n    let rows = await this.db().update(parsedData, options);\n    let copyData = think.extend({}, data, parsedData);\n    await this.afterUpdate(copyData, options);\n    return rows;\n  }\n  /**\n   * update all data\n   * @param  {Array} dataList []\n   * @return {Promise}          []\n   */\n  updateMany(dataList, options){\n    if (!think.isArray(dataList)) {\n      //empty data and options\n      this._options = {};\n      this._data = {};\n\n      return think.reject(new Error(think.locale('DATA_MUST_BE_ARRAY')));\n    }\n    let promises = dataList.map(data => {\n      return this.update(data, options);\n    });\n    return Promise.all(promises).then(data => {\n      return data.reduce((a, b) => a + b);\n    });\n  }\n  /**\n   * increment field data\n   * @return {Promise} []\n   */\n  increment(field, step = 1){\n    let data = {\n      [field]: ['exp', `\\`${field}\\`+${step}`]\n    };\n    return this.update(data);\n  }\n  /**\n   * decrement field data\n   * @return {} []\n   */\n  decrement(field, step = 1){\n    let data = {\n      [field]: ['exp', `\\`${field}\\`-${step}`]\n    };\n    return this.update(data);\n  }\n  /**\n   * find data\n   * @return Promise\n   */\n  async find(options){\n    options = await this.parseOptions(options, {limit: 1});\n    options = await this.beforeFind(options);\n    let data = await this.db().select(options);\n    return this.afterFind(data[0] || {}, options);\n  }\n  /**\n   * select\n   * @return Promise\n   */\n  async select(options){\n    options = await this.parseOptions(options);\n    options = await this.beforeSelect(options);\n    let data = await this.db().select(options);\n    return this.afterSelect(data, options);\n  }\n  /**\n   * select add\n   * @param  {} options []\n   * @return {Promise}         []\n   */\n  async selectAdd(options){\n    let promise = Promise.resolve(options);\n    let Class = module.exports.default || module.exports;\n    if (options instanceof Class) {\n      promise = options.parseOptions();\n    }\n    let data = await Promise.all([this.parseOptions(), promise]);\n    let fields = data[0].field || Object.keys(this.schema);\n    return this.db().selectAdd(fields, data[0].table, data[1]);\n  }\n  /**\n   * count select\n   * @param  options\n   * @param  pageFlag\n   * @return promise\n   */\n  async countSelect(options, pageFlag){\n    let count;\n    if (think.isBoolean(options)) {\n      pageFlag = options;\n      options = {};\n    }else if(think.isNumber(options)){\n      count = options;\n      options = {};\n    }\n\n    options = await this.parseOptions(options);\n    let pk = this.pk;\n    let table = options.alias || this.getTableName();\n\n    //delete table options avoid error when has alias\n    delete options.table;\n    //reserve and delete the possible order option\n    let order = options.order;\n    delete options.order;\n\n    if(!count){\n      count = await this.options(options).count(`${table}.${pk}`);\n    }\n\n    options.limit = options.limit || [0, this.config.nums_per_page];\n    //recover the deleted possible order\n    options.order = order;\n    let numsPerPage = options.limit[1];\n    //get page options\n    let data = {numsPerPage: numsPerPage};\n    let totalPage = Math.ceil(count / data.numsPerPage);\n\n    data.currentPage = parseInt((options.limit[0] / options.limit[1]) + 1);\n\n    if (think.isBoolean(pageFlag) && data.currentPage > totalPage) {\n      if(pageFlag){\n        data.currentPage = 1;\n        options.limit = [0, numsPerPage];\n      }else{\n        data.currentPage = totalPage;\n        options.limit = [(totalPage - 1) * numsPerPage, numsPerPage];\n      }\n    }\n    let result = think.extend({count: count, totalPages: totalPage}, data);\n\n    if(options.cache && options.cache.key){\n      options.cache.key += '_count';\n    }\n    result.data = count ? await this.select(options) : [];\n    return result;\n  }\n  /**\n   * get field data\n   * @return {[type]} [description]\n   */\n  async getField(field, one){\n    let options = await this.parseOptions({'field': field});\n    if (think.isNumber(one)) {\n      options.limit = one;\n    }else if (one === true) {\n      options.limit = 1;\n    }\n    let data = await this.db().select(options);\n    let multi = field.indexOf(',') > -1 && field.indexOf('(') === -1;\n    if (multi) {\n      let fields = field.split(/\\s*,\\s*/);\n      let result = {};\n      fields.forEach(item => result[item] = []);\n      data.every(item => {\n        fields.forEach(fItem => {\n          if (one === true) {\n            result[fItem] = item[fItem];\n          }else{\n            result[fItem].push(item[fItem]);\n          }\n        });\n        return one !== true;\n      });\n      return result;\n    }else{\n      data = data.map(item => {\n        for(let key in item){\n          return item[key];\n        }\n      });\n      return one === true ? data[0] : data;\n    }\n  }\n  /**\n   * get quote field\n   * @param  {String} field []\n   * @return {String}       []\n   */\n  async _getQuoteField(field){\n    if(field){\n      return /^\\w+$/.test(field) ? '`' + field + '`' : field;\n    }\n    return await this.getPk() || '*';\n  }\n  /**\n   * get count\n   * @param  {String} field []\n   * @return {Promise}       []\n   */\n  async count(field){\n    field = await this._getQuoteField(field);\n    return this.getField('COUNT(' + field + ') AS think_count', true);\n  }\n  /**\n   * get sum\n   * @param  {String} field []\n   * @return {Promise}       []\n   */\n  async sum(field){\n    field = await this._getQuoteField(field);\n    return this.getField('SUM(' + field + ') AS think_sum', true);\n  }\n  /**\n   * get min value\n   * @param  {String} field []\n   * @return {Promise}       []\n   */\n  async min(field){\n    field = await this._getQuoteField(field);\n    return this.getField('MIN(' + field + ') AS think_min', true);\n  }\n  /**\n   * get max valud\n   * @param  {String} field []\n   * @return {Promise}       []\n   */\n  async max(field){\n    field = await this._getQuoteField(field);\n    return this.getField('MAX(' + field + ') AS think_max', true);\n  }\n  /**\n   * get value average\n   * @param  {String} field []\n   * @return {Promise}       []\n   */\n  async avg(field){\n    field = await this._getQuoteField(field);\n    return this.getField('AVG(' + field + ') AS think_avg', true);\n  }\n  /**\n   * query\n   * @return {Promise} []\n   */\n  query(...args){\n    let sql = this.parseSql(...args);\n    return this.db().select(sql, this._options.cache);\n  }\n  /**\n   * execute sql\n   * @param  {[type]} sql   [description]\n   * @param  {[type]} parse [description]\n   * @return {[type]}       [description]\n   */\n  execute(...args){\n    let sql = this.parseSql(...args);\n    return this.db().execute(sql);\n  }\n  /**\n   * parse sql\n   * @return promise [description]\n   */\n  parseSql(...args){\n    let sql = util.format(...args);\n    //replace table name\n    return sql.replace(/\\s__([A-Z]+)__\\s/g, (a, b) => {\n      if(b === 'TABLE'){\n        return ' `' + this.getTableName() + '` ';\n      }\n      return ' `' + this.getTablePrefix() + b.toLowerCase() + '` ';\n    });\n  }\n  /**\n   * start transaction\n   * @return {Promise} []\n   */\n  startTrans(){\n    return this.db().startTrans();\n  }\n  /**\n   * commit transcation\n   * @return {Promise} []\n   */\n  commit(){\n    return this.db().commit();\n  }\n  /**\n   * rollback transaction\n   * @return {Promise} []\n   */\n  rollback(){\n    return this.db().rollback();\n  }\n  /**\n   * transaction exec functions\n   * @param  {Function} fn [exec function]\n   * @return {Promise}      []\n   */\n  async transaction(fn){\n    let result;\n    await this.startTrans();\n    try{\n      result = await think.co(fn());\n      await this.commit();\n    }catch(e){\n      await this.rollback();\n    }\n    return result;\n  }\n}\n"]}