{"version":3,"sources":["../../src/model/mongo.js"],"names":[],"mappings":"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","file":"mongo.js","sourcesContent":["'use strict';\n\nimport Base from './_base.js';\n\n/**\n * mongodb model\n */\nexport default class extends Base {\n  /**\n   * get primary key\n   * @return {Promise} []\n   */\n  getPk(){\n    this.pk = '_id';\n    return Promise.resolve(this.pk);\n  }\n  /**\n   * create index from this.indexes\n   * http://docs.mongodb.org/manual/core/indexes-introduction/\n   * @return {Promise} []\n   */\n  async _createIndexes(){\n    let storeKey = `mongo_${this.getTableName()}_indexes`;\n    let isSet = thinkCache(thinkCache.TABLE, storeKey);\n    if(isSet){\n      return;\n    }\n    let indexes = this.indexes;\n    if(think.isEmpty(indexes)){\n      return;\n    }\n\n    return think.await(storeKey, () => {\n      let promises = [];\n      for(let key in indexes){\n        let value = indexes[key];\n        if(think.isObject(value)){\n          let options = {};\n          let val = {};\n          for(let k in value){\n            //key start with $ is options\n            if(k[0] === '$'){\n              options[k.slice(1)] = value[k];\n            }else{\n              val[k] = value[k];\n            }\n          }\n          //if value is empty, auto add key itself\n          if(think.isEmpty(val)){\n            val[key] = 1;\n          }\n          promises.push(this.createIndex(val, options));\n        }else{\n          value = {[key]: value};\n          promises.push(this.createIndex(value));\n        }\n      }\n      return Promise.all(promises).then(() => {\n        thinkCache(thinkCache.TABLE, storeKey, 1);\n      });\n\n    });\n  }\n  /**\n   * parse options\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async parseOptions(oriOpts, extraOptions){\n    let options = think.extend({}, this._options);\n    if (think.isObject(oriOpts)) {\n      options = think.extend(options, oriOpts, extraOptions);\n    }\n    //clear options\n    this._options = {};\n    //get table name\n    options.table = options.table || this.getTableName();\n\n    options.tablePrefix = this.tablePrefix;\n    options.model = this.getModelName();\n\n    if(!think.isObject(oriOpts)){\n      options = think.extend(options, oriOpts, extraOptions);\n    }\n    \n    await this._createIndexes();\n\n    return this.optionsFilter(options);\n  }\n  /**\n   * parse data\n   * @param  {Object} data []\n   * @return {Object}      []\n   */\n  parseData(data){\n    return data;\n  }\n  /**\n   * get table connection\n   * @return {Promise} []\n   */\n  collection(table){\n    table = table || this.getTableName();\n    return this.db().collection(table);\n  }\n  /**\n   * add data\n   * @param {Object} data    []\n   * @param {Object} options []\n   */\n  async add(data, options){\n    //copy data\n    data = think.extend({}, this._data, data);\n    //clear data\n    this._data = {};\n    if (think.isEmpty(data)) {\n      let msg = new Error(think.locale('DATA_EMPTY'));\n      return think.reject(msg);\n    }\n    options = await this.parseOptions(options);\n    data = await this.beforeAdd(data, options);\n    data = this.parseData(data);\n    await this.db().add(data, options);\n    await this.afterAdd(data, options);\n    return this.db().getLastInsertId();\n  }\n   /**\n   * then add\n   * @param  {Object} data       []\n   * @param  {Object} where      []\n   * @return {}            []\n   */\n  async thenAdd(data, where){\n    let findData = await this.where(where).find();\n    if(!think.isEmpty(findData)){\n      return {[this.pk]: findData[this.pk], type: 'exist'};\n    }\n    let insertId = await this.add(data);\n    return {[this.pk]: insertId, type: 'add'};\n  }\n  /**\n   * update data when exist, otherwise add data\n   * @return {id}\n   */\n  async thenUpdate(data, where){\n    let findData = await this.where(where).find();\n    if(think.isEmpty(findData)){\n      return this.add(data);\n    }\n    await this.where(where).update(data);\n    return findData[this.pk];\n  }\n  /**\n   * add multi data\n   * @param {Object} data    []\n   * @param {} options []\n   * @param {} replace []\n   */\n  async addMany(data, options){\n    if (!think.isArray(data) || !think.isObject(data[0])) {\n      let err = new Error(think.locale('DATA_MUST_BE_ARRAY'));\n      return think.reject(err);\n    }\n    options = await this.parseOptions(options);\n    data = await this.beforeAdd(data, options);\n    await this.db().addMany(data, options);\n    await this.afterAdd(data, options);\n    return this.db().getLastInsertId();\n  }\n  /**\n   * delete data\n   * @return {} []\n   */\n  async delete(options){\n    options = await this.parseOptions(options);\n    options = await this.beforeDelete(options);\n    let data = await this.db().delete(options);\n    await this.afterDelete(options);\n    return data.result.n || 0;\n  }\n  /**\n   * update data\n   * @return {Promise} []\n   */\n  async update(data, options, ignoreDefault){\n    if(think.isBoolean(options)){\n      ignoreDefault = options;\n      options = {};\n    }\n    options = await this.parseOptions(options);\n    let pk = await this.getPk();\n    if(data[pk]){\n      this.where({[pk]: data[pk]});\n      delete data[pk];\n    }\n    if(ignoreDefault !== true){\n      data = await this.beforeUpdate(data, options);\n    }\n    let result = await this.db().update(data, options);\n    await this.afterUpdate(data, options);\n    return result.result.nModified || 0;\n  }\n  /**\n   * update many data\n   * @param  {Promise} dataList []\n   * @return {Promise}          []\n   */\n  async updateMany(dataList, options){\n    if (!think.isArray(dataList)) {\n      return think.reject(new Error(think.locale('DATA_MUST_BE_ARRAY')));\n    }\n    let promises = dataList.map(data => {\n      return this.update(data, options);\n    });\n    return Promise.all(promises).then(data => {\n      return data.reduce((a, b) => a + b);\n    });\n  }\n  /**\n   * select data\n   * @return {Promise} []\n   */\n  async select(options){\n    options = await this.parseOptions(options);\n    options = await this.beforeSelect(options);\n    let data = await this.db().select(options);\n    return this.afterSelect(data, options);\n  }\n  /**\n   * count select\n   * @param  {Object} options  []\n   * @param  {Boolean} pageFlag []\n   * @return {Promise}          []\n   */\n  async countSelect(options, pageFlag){\n    let count;\n    if (think.isBoolean(options)) {\n      pageFlag = options;\n      options = {};\n    }else if(think.isNumber(options)){\n      count = options;\n      options = {};\n    }\n\n    options = await this.parseOptions(options);\n    if(!count){\n      //get count\n      count = await this.options(options).count();\n    }\n\n    options.limit = options.limit || [0, this.config.nums_per_page];\n\n    let numsPerPage = options.limit[1];\n    //get page options\n    let data = {numsPerPage: numsPerPage};\n    data.currentPage = parseInt((options.limit[0] / options.limit[1]) + 1);\n    let totalPage = Math.ceil(count / data.numsPerPage);\n    if (think.isBoolean(pageFlag) && data.currentPage > totalPage) {\n      if(pageFlag){\n        data.currentPage = 1;\n        options.limit = [0, numsPerPage];\n      }else{\n        data.currentPage = totalPage;\n        options.limit = [(totalPage - 1) * numsPerPage, numsPerPage];\n      }\n    }\n    let result = think.extend({count: count, totalPages: totalPage}, data);\n    result.data = count ? await this.select(options) : [];\n    return result;\n  }\n  /**\n   * select one row data\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async find(options){\n    options = await this.parseOptions(options, {limit: 1});\n    options = await this.beforeFind(options);\n    let data = await this.db().select(options);\n    return this.afterFind(data[0] || {}, options);\n  }\n  /**\n   * increment field data\n   * @param  {String} field []\n   * @param  {Number} step  []\n   * @return {Promise}       []\n   */\n  async increment(field, step = 1){\n    let options = await this.parseOptions(options);\n    return this.db().update({\n      $inc: {\n        [field]: step\n      }\n    }, options).then(data => {\n      return data.result.n;\n    });\n  }\n  /**\n   * decrement field data\n   * @param  {String} field []\n   * @param  {Number} step  []\n   * @return {Promise}       []\n   */\n  async decrement(field, step = 1){\n    let options = await this.parseOptions(options);\n    return this.db().update({\n      $inc: {\n        [field]: 0 - step\n      }\n    }, options).then(data => {\n      return data.result.n;\n    });\n  }\n  /**\n   * get count \n   * @param  {String} field []\n   * @return {Promise}       []\n   */\n  async count(field){\n    this.field(field);\n    let options = await this.parseOptions();\n    return this.db().count(options);\n  }\n  /**\n   * get sum\n   * @param  {String} field []\n   * @return {Promise}       []\n   */\n  async sum(field){\n    this.field(field);\n    let options = await this.parseOptions();\n    return this.db().sum(options);\n  }\n  /**\n   * aggregate\n   * http://docs.mongodb.org/manual/reference/sql-aggregation-comparison/\n   * @param  {} options []\n   * @return {}         []\n   */\n  aggregate(options){\n    return this.db().aggregate(this.getTableName(), options);\n  }\n  /**\n   * map reduce\n   * Examples: http://docs.mongodb.org/manual/tutorial/map-reduce-examples/\n   * @param  {Function} map    []\n   * @param  {Function} reduce []\n   * @param  {Object} out    []\n   * @return {Promise}        []\n   */\n  mapReduce(map, reduce, out){\n    return this.collection().then(collection => {\n      return collection.mapReduce(map, reduce, out);\n    });\n  }\n  /**\n   * create indexes\n   * @param  {Object} indexes []\n   * @return {Promise}         []\n   */\n  createIndex(indexes, options){\n    return this.db().ensureIndex(this.getTableName(), indexes, options);\n  }\n  /**\n   * get collection indexes\n   * @return {Promise} []\n   */\n  getIndexes(){\n    return this.collection().then(collection => {\n      return collection.indexes();\n    });\n  }\n}\n"]}