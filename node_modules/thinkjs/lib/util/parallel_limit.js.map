{"version":3,"sources":["../../src/util/parallel_limit.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAYE,I,iBAAK,K,EAAO,Q,EAAS;AACnB,QAAG,MAAM,UAAN,CAAiB,KAAjB,CAAH,EAA2B;AACzB,iBAAW,KAAX;AACA,cAAQ,CAAR;AACD;AACD,SAAK,KAAL,GAAa,SAAS,EAAtB;AACA,SAAK,KAAL,GAAa,CAAb;AACA,SAAK,KAAL,GAAa,CAAb;AACA,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,SAAL,GAAiB,EAAjB;AACD,G;;;;;;;mBAKD,G,gBAAI,I,EAAK;AACP,QAAI,WAAW,MAAM,KAAN,EAAf;AACA,aAAS,IAAT,GAAgB,IAAhB;AACA,SAAK,SAAL,CAAe,IAAf,CAAoB,QAApB;AACA,SAAK,GAAL;AACA,WAAO,SAAS,OAAhB;AACD,G;;;;;;;mBAKD,O,oBAAQ,Q,EAAU,W,EAAY;AAAA;;AAC5B,QAAI,MAAM,OAAN,CAAc,QAAd,CAAJ,EAA6B;AAC3B,aAAO,kBAAQ,OAAR,EAAP;AACD;AACD,QAAI,WAAW,SAAS,GAAT,CAAa,gBAAQ;AAClC,UAAI,UAAU,OAAK,GAAL,CAAS,IAAT,CAAd;AACA,aAAO,cAAc,QAAQ,KAAR,CAAc,YAAM,CAAE,CAAtB,CAAd,GAAwC,OAA/C;AACD,KAHc,CAAf;AAIA,WAAO,kBAAQ,GAAR,CAAY,QAAZ,CAAP;AACD,G;;;;;;;mBAKD,I,mBAAM;AACJ,SAAK,KAAL;;;AAGA,SAAK,SAAL,CAAe,MAAf,CAAsB,KAAK,KAAL,GAAa,CAAnC,EAAsC,CAAtC;AACA,SAAK,KAAL;;AAEA,SAAK,GAAL;AACD,G;;;;;;;mBAKD,G,kBAAK;AAAA;;AACH,QAAI,KAAK,KAAL,IAAc,KAAK,KAAnB,IAA4B,KAAK,KAAL,IAAc,KAAK,SAAL,CAAe,MAA7D,EAAqE;AACnE;AACD;AACD,SAAK,KAAL;AACA,QAAI,OAAO,KAAK,SAAL,CAAe,KAAK,KAAL,EAAf,CAAX;AACA,QAAI,WAAW,MAAM,UAAN,CAAiB,KAAK,IAAtB,IAA8B,KAAK,IAAnC,GAA0C,KAAK,QAA9D;AACA,QAAI,CAAC,MAAM,UAAN,CAAiB,QAAjB,CAAL,EAAiC;AAC/B,YAAM,IAAI,KAAJ,CAAU,0CAAV,CAAN;AACD;AACD,QAAI,SAAS,SAAS,KAAK,IAAd,CAAb;AACA,QAAI,CAAC,MAAM,SAAN,CAAgB,MAAhB,CAAL,EAA8B;AAC5B,eAAS,kBAAQ,OAAR,CAAgB,MAAhB,CAAT;AACD;AACD,WAAO,OAAO,IAAP,CAAY,gBAAQ;AACzB,aAAK,IAAL;;AAEA,WAAK,OAAL,CAAa,IAAb;AACD,KAJM,EAIJ,KAJI,CAIE,eAAO;AACd,aAAK,IAAL;;AAEA,WAAK,MAAL,CAAY,GAAZ;AACD,KARM,CAAP;AASD,G;;;EAnF0B,MAAM,I","file":"parallel_limit.js","sourcesContent":["'use strict';\n\n/**\n * parallel limit\n */\nexport default class extends think.base {\n  /**\n   * limit\n   * @param  {[type]}   limit    []\n   * @param  {Function} callback []\n   * @return {[type]}            []\n   */\n  init(limit, callback){\n    if(think.isFunction(limit)){\n      callback = limit;\n      limit = 0;\n    }\n    this.limit = limit || 10;\n    this.index = 0;\n    this.doing = 0;\n    this.callback = callback;\n    this.deferreds = [];\n  }\n  /**\n   * add item data\n   * @param {data} item []\n   */\n  add(item){\n    let deferred = think.defer();\n    deferred.data = item;\n    this.deferreds.push(deferred);\n    this.run();\n    return deferred.promise;\n  }\n  /**\n   * add many data once\n   * @param {Array} dataList [data array]\n   */\n  addMany(dataList, ignoreError){\n    if (think.isEmpty(dataList)) {\n      return Promise.resolve();\n    }\n    let promises = dataList.map(item => {\n      let promise = this.add(item);\n      return ignoreError ? promise.catch(() => {}) : promise;\n    });\n    return Promise.all(promises);\n  }\n  /**\n   * next\n   * @return {Function} [description]\n   */\n  next(){\n    this.doing --;\n\n    //reduce deferreds avoid memory leak when use single item data\n    this.deferreds.splice(this.index - 1, 1);\n    this.index--;\n\n    this.run();\n  }\n  /**\n   * run\n   * @return {} []\n   */\n  run(){\n    if (this.doing >= this.limit || this.index >= this.deferreds.length) {\n      return;\n    }\n    this.doing++;\n    let item = this.deferreds[this.index++];\n    let callback = think.isFunction(item.data) ? item.data : this.callback;\n    if (!think.isFunction(callback)) {\n      throw new Error('data item or callback must be a function');\n    }\n    let result = callback(item.data);\n    if (!think.isPromise(result)) {\n      result = Promise.resolve(result);\n    }\n    return result.then(data => {\n      this.next();\n      //resolve item\n      item.resolve(data);\n    }).catch(err => {\n      this.next();\n      //reject item\n      item.reject(err);\n    });\n  }\n}"]}