{"version":3,"sources":["../../../src/adapter/db/mongo.js"],"names":[],"mappings":"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","file":"mongo.js","sourcesContent":["'use strict';\n\nimport Parse from './_parse_mongo.js';\n\nlet MongoSocket = think.adapter('socket', 'mongo');\n\n/**\n * mongo db class\n */\nexport default class extends Parse {\n  /**\n   * init\n   * @param  {Object} config []\n   * @return {}        []\n   */\n  init(config){\n    super.init();\n    this.config = config;\n    this.lastInsertId = 0;\n    this._socket = null; //Mongo socket instance\n  }\n  /**\n   * connect mongo socket\n   * @return {Promise} []\n   */\n  socket(){\n    if(this._socket){\n      return this._socket;\n    }\n    this._socket = MongoSocket.getInstance(this.config, thinkCache.DB);\n    return this._socket;\n  }\n  /**\n   * get connection\n   * @return {Promise} []\n   */\n  collection(table){\n    let instance = this.socket();\n    return instance.getConnection().then(db => db.collection(table));\n  }\n  /**\n   * get last insert id\n   * @return {String} []\n   */\n  getLastInsertId(){\n    return this.lastInsertId;\n  }\n  /**\n   * add data\n   * @param {Objec} data    []\n   * @param {Object} options []\n   */\n  async add(data, options){\n    let collection = await this.collection(options.table);\n    let result = await collection.insert(data);\n    this.lastInsertId = data._id.toString();\n    return result;\n  }\n  /**\n   * add multi data\n   * @param {Array} dataList []\n   * @param {Object} options [ {ordered: true}. If false, perform an unordered insert, and if an error occurs with one of documents, continue processing the remaining documents in the array.}]\n   * @param {Object} options  []\n   */\n  async addMany(dataList, options){\n    let collection = await this.collection(options.table);\n    let result = await collection.insert(dataList, options);\n    let insertedIds = dataList.map(item => {\n      return item._id.toString();\n    });\n    this.lastInsertId = insertedIds;\n    return result;\n  }\n  /**\n   * set collection limit\n   * @param  {Object} collection []\n   * @param  {String} limit      []\n   * @return {Object}            []\n   */\n  limit(collection, limit){\n    limit = this.parseLimit(limit);\n    if(limit[0]){\n      collection.skip(limit[0]);\n    }\n    if(limit[1]){\n      collection.limit(limit[1]);\n    }\n    return collection;\n  }\n  /**\n   * parse group\n   * @param  {String} group []\n   * @return {Object}       []\n   */\n  group(group){\n    group = this.parseGroup(group);\n    let length = group.length;\n    if(length === 0){\n      return {_id: null};\n    }else if(length === 1){\n      return {_id: `$${group[0]}`};\n    }else {\n      let result = {};\n      group.forEach(item => {\n        result[item] = `$${item}`;\n      });\n      return result;\n    }\n  }\n  /**\n   * select data\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async select(options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n\n    //get distinct field data\n    let distinct = this.parseDistinct(options.distinct);\n    if(distinct){\n      return collection.distinct(distinct, where);\n    }\n\n    collection = collection.find(where, this.parseField(options.field));\n    collection = this.limit(collection, options.limit);\n    collection = collection.sort(this.parseOrder(options.order));\n    return collection.toArray();\n  }\n  /**\n   * update data\n   * @param  {Object} data    []\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async update(data, options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n\n    let limit = this.parseLimit(options.limit);\n    // updates multiple documents that meet the query criteria. \n    // default only updates one document\n    if(limit[1] !== 1){\n      options.multi = true;\n    }\n\n    // If set to true, creates a new document when no document matches the query criteria. \n    // The default value is false, which does not insert a new document when no match is found.\n    if(!options.upsert){\n      options.upsert = false;\n    }\n\n    //add $set for data\n    let flag = true;\n    for(let key in data){\n      if(key[0] !== '$'){\n        flag = false;\n        break;\n      }\n    }\n    if(!flag){\n      data = {$set: data};\n    }\n\n    // update operator\n    // http://docs.mongodb.org/manual/reference/operator/update/#id1\n    return collection.update(where, data, options);\n  }\n  /**\n   * delete data\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async delete(options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n    let limit = this.parseLimit(options.limit);\n\n    //delete one row\n    let removeOpt = {};\n    if(limit[1] === 1){\n      removeOpt.justOne = true;\n    }\n    \n    return collection.remove(where, removeOpt);\n  }\n  /**\n   * get count\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async count(options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n\n    let group = this.group(options.group);\n    group.total = {$sum: 1};\n\n    let order = this.parseOrder(options.order);\n\n    let aggregate = [];\n    if(!think.isEmpty(where)){\n      aggregate.push({$match: where});\n    }\n    aggregate.push({$group: group});\n    if(!think.isEmpty(order)){\n      aggregate.push({$sort: order});\n    }\n    //make aggregate method to be a promise\n    let fn = think.promisify(collection.aggregate, collection);\n    return fn(aggregate).then(data => {\n      return data[0] && data[0].total || 0;\n    });\n  }\n  /**\n   * get sum\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  async sum(options){\n    let collection = await this.collection(options.table);\n    let where = this.parseWhere(options.where);\n\n    let group = this.group(options.group);\n    group.total = {$sum: `$${options.field}`};\n\n    let order = this.parseOrder(options.order);\n\n    let aggregate = [];\n    if(!think.isEmpty(where)){\n      aggregate.push({$match: where});\n    }\n    aggregate.push({$group: group});\n    if(!think.isEmpty(order)){\n      aggregate.push({$sort: order});\n    }\n    //make aggregate method to be a promise\n    let fn = think.promisify(collection.aggregate, collection);\n    return fn(aggregate).then(data => {\n      return data[0] && data[0].total || 0;\n    });\n  }\n  /**\n   * create collection indexes\n   * @param  {String} table   []\n   * @param  {Object} indexes []\n   * @return {Promise}         []\n   */\n  ensureIndex(table, indexes, options = {}){\n    if(options === true){\n      options = {unique: true};\n    }\n    if(think.isString(indexes)){\n      indexes = indexes.split(/\\s*,\\s*/);\n    }\n    if(think.isArray(indexes)){\n      let result = {};\n      indexes.forEach(item => {\n        result[item] = 1;\n      });\n      indexes = result;\n    }\n    return this.collection(table).then(collection => {\n      return collection.ensureIndex(indexes, options);\n    });\n  }\n  /**\n   * aggregate\n   * @param  {String} table   []\n   * @param  {Object} options []\n   * @return {Promise}         []\n   */\n  aggregate(table, options){\n    return this.collection(table).then(collection => {\n      let fn = think.promisify(collection.aggregate, collection);\n      return fn(options);\n    });\n  }\n  /**\n   * close socket\n   * @return {} []\n   */\n  close(){\n    if(this._socket){\n      this._socket.close();\n      this._socket = null;\n    }\n  }\n}"]}