{"version":3,"sources":["../../../src/adapter/db/postgresql.js"],"names":[],"mappings":"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","file":"postgresql.js","sourcesContent":["'use strict';\n\nimport Base from './base.js';\n\nlet PostgreSocket = think.adapter('socket', 'postgresql');\n/**\n * postgre db\n */\nexport default class extends Base {\n  /**\n   * get postgre socket instance\n   * @param  {Object} config []\n   * @return {}        []\n   */\n  socket(sql){\n    if(this._socket){\n      return this._socket;\n    }\n    let config = think.extend({\n      sql: sql\n    }, this.config);\n    this._socket = PostgreSocket.getInstance(config, thinkCache.DB, ['sql']);\n    return this._socket;\n  }\n  /**\n   * get table info\n   * @param  {String} table [table name]\n   * @return {Promise}       []\n   */\n  async getSchema(table){\n    let columnSql = `SELECT column_name,is_nullable,data_type FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name='${table}'`;\n    let columnsPromise = this.query(columnSql);\n    let indexSql = `SELECT indexname,indexdef FROM pg_indexes WHERE tablename='${table}'`;\n    let indexPromise = this.query(indexSql);\n    let [columns, indexs] = await Promise.all([columnsPromise, indexPromise]);\n    let schema = {};\n    columns.forEach(item => {\n      schema[item.column_name] = {\n        name: item.column_name,\n        type: item.data_type,\n        required: item.is_nullable === 'NO',\n        default: '',\n        auto_increment: false\n      };\n    });\n    let extra = {};\n    let reg = /\\((\\w+)(?:, (\\w+))*\\)/;\n    indexs.forEach(item => {\n      let [, name, ...others] = item.indexdef.match(reg);\n      extra[name] = {};\n      if(item.indexdef.indexOf(' pkey ') > -1){\n        extra[name].primary = true;\n      }\n      let index = item.indexdef.indexOf(' UNIQUE ') > -1 ? 'unique' : 'index';\n      extra[name][index] = others.length ? others : true;\n    });\n\n    return think.extend(schema, extra);\n  }\n  /**\n   * start transaction\n   * @return {Promise} []\n   */\n  startTrans(){\n    if (this.transTimes === 0) {\n      this.transTimes++;\n      return this.execute('BEGIN');\n    }\n    this.transTimes++;\n    return Promise.resolve();\n  }\n  /**\n   * parse limit\n   * @param  {String} limit []\n   * @return {String}       []\n   */\n  parseLimit(limit){\n    if (think.isEmpty(limit)) {\n      return '';\n    }\n    if(think.isNumber(limit)){\n      return ` LIMIT ${limit}`;\n    }\n    if(think.isString(limit)){\n      limit = limit.split(/\\s*,\\s*/);\n    }\n    if(limit[1]){\n      return ' LIMIT ' + (limit[1] | 0) + ' OFFSET ' + (limit[0] | 0);\n    }\n    return ' LIMIT ' + (limit[0] | 0);\n  }\n  /**\n   * parse value\n   * @param  {Mixed} value []\n   * @return {Mixed}       []\n   */\n  parseValue(value){\n    if (think.isString(value)) {\n      value = 'E\\'' + this.escapeString(value) + '\\'';\n    }else if(think.isArray(value)){\n      if (/^exp$/.test(value[0])) {\n        value = value[1];\n      }else{\n        value = value.map(item => this.parseValue(item));\n      }\n    }else if(think.isBoolean(value)){\n      value = value ? 'true' : 'false';\n    }else if (value === null) {\n      value = 'null';\n    }\n    return value;\n  }\n  /**\n   * query string\n   * @param  string str\n   * @return promise\n   */\n  query(sql){\n    this.sql = sql;\n    return think.await(sql, () => {\n      return this.socket(sql).query(sql).then(data => {\n        return this.bufferToString(data.rows);\n      });\n    });\n  }\n  /**\n   * execute sql\n   * @param  {String} sql []\n   * @return {}     []\n   */\n  execute(sql){\n    this.sql = sql;\n    let insertInto = 'insert into ';\n    let prefix = sql.slice(0, insertInto.length).toLowerCase();\n    let isInsert = false;\n    if(prefix === insertInto){\n      sql += ' RETURNING id';\n      isInsert = true;\n    }\n    return this.socket(sql).execute(sql).then(data => {\n      if(isInsert){\n        this.lastInsertId = data.rows[0].id;\n      }\n      return data.rowCount || 0;\n    });\n  }\n}"]}