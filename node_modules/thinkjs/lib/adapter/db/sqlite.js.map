{"version":3,"sources":["../../../src/adapter/db/sqlite.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;AAEA,IAAI,eAAe,MAAM,OAAN,CAAc,QAAd,EAAwB,QAAxB,CAAnB;;;;;;;;;;;;;;;;;;;mBAUE,M,mBAAO,G,EAAI;AACT,QAAG,KAAK,OAAR,EAAgB;AACd,aAAO,KAAK,OAAZ;AACD;AACD,QAAI,SAAS,MAAM,MAAN,CAAa;AACxB,WAAK;AADmB,KAAb,EAEV,KAAK,MAFK,CAAb;AAGA,SAAK,OAAL,GAAe,aAAa,WAAb,CAAyB,MAAzB,EAAiC,WAAW,EAA5C,EAAgD,CAAC,KAAD,CAAhD,CAAf;AACA,WAAO,KAAK,OAAZ;AACD,G;;;;;;;;mBAMK,S;0FAAU,K;;;UACV,Y,EACA,Y,EAeA,G,QACC,I,EAAM,O;;;;;;AAjBP,0B,GAAe,KAAK,KAAL,yBAAiC,KAAjC,Q;AACf,0B,GAAe,KAAK,KAAL,yBAAiC,KAAjC,SAA4C,IAA5C,CAAiD,gBAAQ;AAC1E,oBAAI,UAAU,EAAd;AACA,oBAAI,WAAW,KAAK,GAAL,CAAS,gBAAQ;AAC9B,sBAAG,KAAK,MAAR,EAAe;AACb,2BAAO,OAAK,KAAL,yBAAiC,KAAK,IAAtC,SAAgD,IAAhD,CAAqD,gBAAQ;AAClE,2BAAK,OAAL,CAAa,gBAAQ;AACnB,gCAAQ,KAAK,IAAb,IAAqB,EAAC,QAAQ,IAAT,EAArB;AACD,uBAFD;AAGD,qBAJM,CAAP;AAKD;AACF,iBARc,CAAf;AASA,uBAAO,kBAAQ,GAAR,CAAY,QAAZ,EAAsB,IAAtB,CAA2B,YAAM;AACtC,yBAAO,OAAP;AACD,iBAFM,CAAP;AAGD,eAdkB,C;AAef,iB,GAAM,E;;qBACkB,kBAAQ,GAAR,CAAY,CAAC,YAAD,EAAe,YAAf,CAAZ,C;;;;AAAvB,kB;AAAM,qB;;AACX,mBAAK,OAAL,CAAa,gBAAQ;AACnB,oBAAI,KAAK,IAAT,IAAiB;AACf,wBAAM,KAAK,IADI;AAEf,wBAAM,KAAK,IAFI;AAGf,4BAAU,CAAC,CAAC,KAAK,OAHF;;AAKf,2BAAS,CAAC,CAAC,KAAK,EALD;AAMf,kCAAgB,KAND;AAOf,0BAAQ,CAAC,EAAE,CAAC,KAAK,EAAN,IAAY,QAAQ,KAAK,IAAb,CAAZ,IAAkC,QAAQ,KAAK,IAAb,EAAmB,MAAvD;AAPM,iBAAjB;AASD,eAVD;+CAWO,G;;;;;;;;;;;;;;;;;;;;;;mBAMT,U,yBAAY;AACV,QAAI,KAAK,UAAL,KAAoB,CAAxB,EAA2B;AACzB,WAAK,UAAL;AACA,aAAO,KAAK,OAAL,CAAa,mBAAb,CAAP;AACD;AACD,SAAK,UAAL;AACA,WAAO,kBAAQ,OAAR,EAAP;AACD,G;;;;;;;;mBAMD,Y,yBAAa,G,EAAI;AACf,WAAO,IAAI,OAAJ,CAAY,KAAZ,EAAmB,MAAnB,CAAP;AACD,G;;;;;;;;mBAMD,U,uBAAW,K,EAAM;AACf,QAAI,MAAM,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,aAAO,EAAP;AACD;AACD,QAAG,MAAM,QAAN,CAAe,KAAf,CAAH,EAAyB;AACvB,yBAAiB,KAAjB;AACD;AACD,QAAG,MAAM,QAAN,CAAe,KAAf,CAAH,EAAyB;AACvB,cAAQ,MAAM,KAAN,CAAY,SAAZ,CAAR;AACD;AACD,QAAG,MAAM,CAAN,CAAH,EAAY;AACV,aAAO,aAAa,MAAM,CAAN,IAAW,CAAxB,IAA6B,UAA7B,IAA2C,MAAM,CAAN,IAAW,CAAtD,CAAP;AACD;AACD,WAAO,aAAa,MAAM,CAAN,IAAW,CAAxB,CAAP;AACD,G","file":"sqlite.js","sourcesContent":["'use strict';\n\nimport Base from './base.js';\n\nlet SqliteSocket = think.adapter('socket', 'sqlite');\n/**\n * sqlite db\n */\nexport default class extends Base {\n  /**\n   * get sqlite socket instance\n   * @param  {Object} config []\n   * @return {}        []\n   */\n  socket(sql){\n    if(this._socket){\n      return this._socket;\n    }\n    let config = think.extend({\n      sql: sql\n    }, this.config);\n    this._socket = SqliteSocket.getInstance(config, thinkCache.DB, ['sql']);\n    return this._socket;\n  }\n  /**\n   * get table info\n   * @param  {String} table [table name]\n   * @return {Promise}       []\n   */\n  async getSchema(table){\n    let fieldPromise = this.query(`PRAGMA table_info( ${table} )`);\n    let indexPromise = this.query(`PRAGMA INDEX_LIST( ${table} )`).then(list => {\n      let indexes = {};\n      let promises = list.map(item => {\n        if(item.unique){\n          return this.query(`PRAGMA index_info( ${item.name} )`).then(data => {\n            data.forEach(item => {\n              indexes[item.name] = {unique: true};\n            });\n          });\n        }\n      });\n      return Promise.all(promises).then(() => {\n        return indexes;\n      });\n    });\n    let ret = {};\n    let [data, indexes] = await Promise.all([fieldPromise, indexPromise]);\n    data.forEach(item => {\n      ret[item.name] = {\n        name: item.name,\n        type: item.type,\n        required: !!item.notnull,\n        //default: item.dflt_value,\n        primary: !!item.pk,\n        auto_increment: false,\n        unique: !!(!item.pk && indexes[item.name] && indexes[item.name].unique)\n      };\n    });\n    return ret;\n  }\n  /**\n   * start transaction\n   * @return {Promise} []\n   */\n  startTrans(){\n    if (this.transTimes === 0) {\n      this.transTimes++;\n      return this.execute('BEGIN TRANSACTION');\n    }\n    this.transTimes++;\n    return Promise.resolve();\n  }\n  /**\n   * escape string\n   * @param  {String} str []\n   * @return {String}     []\n   */\n  escapeString(str){\n    return str.replace(/\\'/g, '\\'\\'');\n  }\n  /**\n   * parse limit\n   * @param  {Array} limit []\n   * @return {String}       []\n   */\n  parseLimit(limit){\n    if (think.isEmpty(limit)) {\n      return '';\n    }\n    if(think.isNumber(limit)){\n      return ` LIMIT ${limit}`;\n    }\n    if(think.isString(limit)){\n      limit = limit.split(/\\s*,\\s*/);\n    }\n    if(limit[1]){\n      return ' LIMIT ' + (limit[1] | 0) + ' OFFSET ' + (limit[0] | 0);\n    }\n    return ' LIMIT ' + (limit[0] | 0);\n  }\n}"]}