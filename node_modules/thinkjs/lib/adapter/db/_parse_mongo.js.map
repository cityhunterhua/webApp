{"version":3,"sources":["../../../src/adapter/db/_parse_mongo.js"],"names":[],"mappings":"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","file":"_parse_mongo.js","sourcesContent":["'use strict';\n\nexport default class extends think.base {\n  /**\n   * init\n   * @return {} []\n   */\n  init(){\n    this.comparison = {\n      'EQ': '$eq',\n      '=': '$eq',\n      'NEQ': '$ne',\n      '!=': '$ne',\n      '<>': '$ne',\n      'GT': '$gt',\n      '>': '$gt',\n      'EGT': '$gte',\n      '>=': '$gte',\n      'LT': '$lt',\n      '<': '$lt',\n      'ELT': '$lte',\n      '<=': '$lte',\n      'OR': '$or',\n      'IN': '$in',\n      'NOTIN': '$nin'\n    };\n  }\n  /**\n   * parse field\n   * @param  {String} field   []\n   * @param  {Boolean} reverse []\n   * @return {Object}         []\n   */\n  parseField(field, reverse){\n    if(!field){\n      return {};\n    }\n    if(think.isString(field)){\n      field = field.split(/\\s*,\\s*/);\n    }\n    if(think.isArray(field)){\n      let result = {};\n      field.forEach(item => {\n        result[item] = reverse ? 0 : 1;\n      });\n      return result;\n    }\n    if(reverse){\n      for(let key in field){\n        field[key] = 0;\n      }\n    }\n    return field;\n  }\n  /**\n   * parse limit\n   * @param  {Object} collection []\n   * @param  {Array} limit      []\n   * @return {Object}            []\n   */\n  parseLimit(limit){\n    if(!limit){\n      return [];\n    }\n    if(think.isNumber(limit)){\n      return [0, limit];\n    }\n    if(think.isString(limit)){\n      limit = limit.split(/\\s*,\\s*/);\n    }\n    let skip = limit[0] | 0;\n    let limitNum = limit[1] | 0;\n    if(limitNum){\n      return [skip, limitNum];\n    }\n    return [0, skip];\n  }\n  /**\n   * parse order\n   * @param  {String} order []\n   * @return {Object}       []\n   */\n  parseOrder(order){\n    if(!order){\n      return {};\n    }\n    if(order === true || order === 'natural'){\n      return {\n        $natural: 1\n      };\n    }\n    if(think.isString(order)){\n      order = order.split(/\\s*,\\s*/);\n      let result = {};\n      order.forEach(item => {\n        item = item.split(' ');\n        let type = (item[1] || '').toLowerCase();\n        result[item[0].trim()] = type === 'desc' ? -1 : 1;\n      });\n      return result;\n    }\n    for(let key in order){\n      if(order[key] === false || order[key] === 0){\n        order[key] = -1;\n      }else if(order[key] !== -1){\n        order[key] = 1;\n      }\n    }\n    return order;\n  }\n  /**\n   * parse group\n   * @param  {String} group []\n   * @return {Object}       []\n   */\n  parseGroup(group){\n    if (think.isEmpty(group)) {\n      return '';\n    }\n    if (think.isString(group)) {\n      group = group.split(/\\s*,\\s*/);\n    }\n    return group;\n  }\n  /**\n   * parse where\n   * http://docs.mongodb.org/manual/reference/operator/query/\n   * @param  {Object} where []\n   * @return {Object}       []\n   */\n  parseWhere(where){\n\n    if(think.isArray(where)){\n      return where.map(item => {\n        return this.parseWhere(item);\n      });\n    }\n    \n    if(think.isObject(where)){\n      let result = {};\n      for(let key in where){\n        let value = where[key];\n        if(key === '_id' && think.isString(value)){\n          let validator = think.require('validator');\n          if(validator.mongoId(value)){\n            let {ObjectID} = think.require('mongodb');\n            result[key] = ObjectID(value);\n            continue;\n          }\n        }\n        key = this.comparison[key] || key;\n        if(think.isObject(value) || think.isArray(value)){\n          value = this.parseWhere(value);\n        }\n        result[key] = value;\n      }\n      return result;\n    }\n    return where || {};\n  }\n  /**\n   * parse distinct\n   * @param  {String} distinct []\n   * @return {String}          []\n   */\n  parseDistinct(distinct){\n    return distinct;\n  }\n}"]}