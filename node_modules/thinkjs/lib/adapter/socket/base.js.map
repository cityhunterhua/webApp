{"version":3,"sources":["../../../src/adapter/socket/base.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAUE,I,mBAAM;AACJ,SAAK,UAAL,GAAkB,IAAlB;;AAEA,SAAK,SAAL,GAAiB,CAAjB;;AAEA,SAAK,UAAL,GAAkB,CAAlB;AACD,G;;;;;;;mBAKD,U,uBAAW,G,EAAK,I,EAAK;;AAEnB,QAAG,KAAK,MAAL,CAAY,WAAf,EAA2B;AACzB,YAAM,GAAN,CAAU,kBAAU;AAClB,eAAO,aAAW,IAAX,cAA0B,OAAO,OAAP,CAAe,GAAf,CAAjC;AACD,OAFD,EAEG,QAFH;AAGD;AACF,G;;;;;;;mBAKD,S,sBAAU,O,EAAQ;AAAA;;AAChB,QAAG,CAAC,MAAM,MAAN,CAAa,mBAAb,CAAJ,EAAsC;AACpC,aAAO,OAAP;AACD;;AAED,QAAI,QAAQ,SAAR,KAAQ,GAAM;AAChB,aAAK,SAAL;AACA,UAAG,OAAK,SAAL,KAAmB,CAAtB,EAAwB;AACtB,eAAK,UAAL,GAAkB,WAAW,YAAM;AACjC,iBAAK,KAAL;AACD,SAFiB,EAEf,IAFe,CAAlB;AAGD;AACF,KAPD;;AASA,iBAAa,KAAK,UAAlB;;AAEA,SAAK,SAAL;AACA,WAAO,QAAQ,IAAR,CAAa,gBAAQ;AAC1B;AACA,aAAO,IAAP;AACD,KAHM,EAGJ,KAHI,CAGE,eAAO;AACd;AACA,aAAO,kBAAQ,MAAR,CAAe,GAAf,CAAP;AACD,KANM,CAAP;AAOD,G;;;;;;;mBAKD,K,oBAAO;AACL,QAAG,KAAK,UAAR,EAAmB;AACjB,WAAK,UAAL,CAAgB,KAAhB;AACA,WAAK,UAAL,GAAkB,IAAlB;AACD;AACF,G;;;;;;;;;SAOM,W,wBAAY,M,EAAQ,I,EAAqB;AAAA,QAAf,SAAe,yDAAH,EAAG;;AAC9C,aAAS,MAAM,WAAN,CAAkB,MAAlB,CAAT;;;AAGA,cAAU,OAAV,CAAkB;AAAA,aAAQ,OAAO,OAAO,IAAP,CAAf;AAAA,KAAlB;AACA,QAAI,MAAM,MAAM,GAAN,CAAU,yBAAe,MAAf,CAAV,EAAkC,KAAlC,CAAwC,CAAxC,EAA2C,CAA3C,CAAV;;AAEA,QAAI,WAAW,WAAW,IAAX,EAAiB,GAAjB,CAAf;AACA,QAAG,CAAC,QAAJ,EAAa;AACX,iBAAW,IAAI,IAAJ,CAAS,MAAT,CAAX;AACA,iBAAW,IAAX,EAAiB,GAAjB,EAAsB,QAAtB;AACD;AACD,WAAO,QAAP;AACD,G;;;EAlF0B,MAAM,OAAN,CAAc,I","file":"base.js","sourcesContent":["'use strict';\n\n/**\n * socket base class\n */\nexport default class extends think.adapter.base {\n  /**\n   * init\n   * @return {} []\n   */\n  init(){\n    this.connection = null;\n    //query queue nums\n    this.queueNums = 0;\n    //auto close socket timer\n    this.closeTimer = 0;\n  }\n  /**\n   * log connection\n   * @return {} []\n   */\n  logConnect(str, type){\n    //log mongodb connection infomation\n    if(this.config.log_connect){\n      think.log(colors => {\n        return `Connect ${type} with ` + colors.magenta(str);\n      }, 'SOCKET');\n    }\n  }\n  /**\n   * auto close socket on cli mode\n   * @return {Promise} []\n   */\n  autoClose(promise){\n    if(!think.config('auto_close_socket')){\n      return promise;\n    }\n\n    let close = () => {\n      this.queueNums--;\n      if(this.queueNums === 0){\n        this.closeTimer = setTimeout(() => {\n          this.close();\n        }, 3000);\n      }\n    };\n\n    clearTimeout(this.closeTimer);\n\n    this.queueNums++;\n    return promise.then(data => {\n      close();\n      return data;\n    }).catch(err => {\n      close();\n      return Promise.reject(err);\n    });\n  }\n  /**\n   * close socket connection\n   * @return {} []\n   */\n  close(){\n    if(this.connection){\n      this.connection.close();\n      this.connection = null;\n    }\n  }\n\n  /**\n   * get instance\n   * @param  {Object} config []\n   * @return {Object}        []\n   */\n  static getInstance(config, type, extraKeys = []){\n    config = think.parseConfig(config);\n\n    //delete extra keys when caculate config md5 value\n    extraKeys.forEach(item => delete config[item]);\n    let key = think.md5(JSON.stringify(config)).slice(0, 5);\n\n    let instance = thinkCache(type, key);\n    if(!instance){\n      instance = new this(config);\n      thinkCache(type, key, instance);\n    }\n    return instance;\n  }\n}"]}