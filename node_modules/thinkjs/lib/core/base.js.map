{"version":3,"sources":["../../src/core/base.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;AAaE,oBAAoB;AAAA;;AAClB,SAAK,IAAL;AACD;;;;;;;;mBAMD,I,mBAAM,CACL,C;;;;;;;;;mBAOK,M;0FAAO,M;wCAAW,I;AAAA,Y;;;UAQlB,M;;;;;mBAPA,KAAK,Q;;;;;;qBACD,MAAM,EAAN,CAAS,KAAK,QAAL,CAAc,IAAd,CAAT,C;;;kBAGH,KAAK,MAAL,C;;;;;+CACI,kBAAQ,MAAR,CAAe,IAAI,KAAJ,CAAU,MAAM,MAAN,CAAa,kBAAb,EAAiC,MAAjC,CAAV,CAAf,C;;;;qBAEU,MAAM,EAAN,CAAS,KAAK,MAAL,cAAgB,IAAhB,CAAT,C;;;AAAf,oB;;mBACA,KAAK,O;;;;;;qBACD,MAAM,EAAN,CAAS,KAAK,OAAL,CAAa,IAAb,CAAT,C;;;+CAED,M;;;;;;;;;;;;;;;;;;;;;;;mBAOT,Q,uBAAoC;AAAA,QAA3B,QAA2B,yDAAhB,KAAK,UAAW;;AAClC,WAAO,eAAK,QAAL,CAAc,QAAd,EAAwB,KAAxB,CAAP;AACD,G;;;;;;;;mBAMD,mB,kCAA+C;AAAA,QAA3B,QAA2B,yDAAhB,KAAK,UAAW;;AAC7C,QAAI,CAAC,QAAL,EAAc;AACZ,aAAO,EAAP;AACD;AACD,QAAI,MAAM,IAAN,KAAe,MAAM,WAAzB,EAAqC;AACnC,aAAO,EAAP;AACD;AACD,QAAI,SAAS,MAAM,QAAN,GAAiB,MAAM,GAApC;AACA,QAAI,MAAM,SAAS,OAAT,CAAiB,MAAjB,CAAV;AACA,QAAI,QAAQ,CAAC,CAAb,EAAe;AACb,aAAO,EAAP;AACD;AACD,QAAI,UAAU,SAAS,OAAT,CAAiB,MAAM,GAAvB,EAA4B,MAAM,OAAO,MAAzC,CAAd;AACA,QAAI,YAAY,CAAC,CAAjB,EAAmB;AACjB,aAAO,EAAP;AACD;AACD,QAAI,SAAS,SAAS,KAAT,CAAe,MAAM,OAAO,MAA5B,EAAoC,OAApC,CAAb;AACA,QAAI,MAAM,MAAN,CAAa,OAAb,CAAqB,MAArB,IAA+B,CAAC,CAApC,EAAsC;AACpC,aAAO,MAAP;AACD;AACD,WAAO,EAAP;AACD,G","file":"base.js","sourcesContent":["'use strict';\n\nimport path from 'path';\n\n/**\n * Base Class\n * @param  {Object} http\n * @return {Class}\n */\nexport default class {\n  /**\n   * constructor\n   * @param  {Object} http []\n   * @return {}      []\n   */\n  constructor(...args){\n    this.init(...args);\n  }\n  /**\n   * init\n   * @param  {Object} http []\n   * @return {}      []\n   */\n  init(){\n  }\n  /**\n   * invoke method, support __before & __after magic methods\n   * @param  {String} method []\n   * @param  {mixed} data []\n   * @return {Promise}    []\n   */\n  async invoke(method, ...data){\n    if (this.__before) {\n      await think.co(this.__before(this));\n    }\n    // Check whether method exists\n    if (!this[method]){\n      return Promise.reject(new Error(think.locale('METHOD_NOT_EXIST', method)));\n    }\n    let result = await think.co(this[method](...data));\n    if (this.__after) {\n      await think.co(this.__after(this));\n    }\n    return result;\n  }\n  /**\n   * get file basename\n   * @param  {String} filepath []\n   * @return {String}          []\n   */\n  basename(filepath = this.__filename){\n    return path.basename(filepath, '.js');\n  }\n  /**\n   * parse module from filepath\n   * @param  {String} filepath []\n   * @return {String}          []\n   */\n  parseModuleFromPath(filepath = this.__filename){\n    if (!filepath){\n      return '';\n    }\n    if (think.mode !== think.mode_module){\n      return '';\n    }\n    let prefix = think.APP_PATH + think.sep;\n    let pos = filepath.indexOf(prefix);\n    if (pos === -1){\n      return '';\n    }\n    let nextPos = filepath.indexOf(think.sep, pos + prefix.length);\n    if (nextPos === -1){\n      return '';\n    }\n    let module = filepath.slice(pos + prefix.length, nextPos);\n    if (think.module.indexOf(module) > -1){\n      return module;\n    }\n    return '';\n  }\n}\n"]}